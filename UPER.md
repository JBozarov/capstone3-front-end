<h1>The Problem Solving Framework : 'UPER'</h1>

* U = "Understand"
* P = "Plan"
* E = "Execute"
* R = "Reflect" / "Refactor"

<h2>1. Understanding the Problem</h2>
*  Create a working back-end API using Spring Boot
* Include data persistance using a relational/non-relational database
* Incorporate API login authentication using JSON Web Tokens (JWT)
* Create a database schema diagram using a graphical tool such as dbdesigner.net, lucid charts, etc.
* Code should reflect TDD concepts.  Tests should be written for the back end. 
* API should reflect at least one OOP design pattern (Singleton for Database, Factory, Facade, Producer/Consumer, etc)
* Published API documentation using Swagger, Postman, Github, etc.
* Entire application (Front End/Back End) must be deployed and accessible via the web (Netlify, Heroku, Digital Ocean, Oracle Cloud, etc.)
* Bonus functionality includes: 
	-test written for the front end (React-testing-library, Mocha, Chai, Jest)
	-CSS preprocessor/library is used on the front end (Less, Sass, Tailwind)
	-Social medial authentication using OAuth (Google, Facebook, LinkedIn, Github, etc.)
	
<h2>
    2. Planning the Solution
</h2>
* Before work began, the group held a "kick-off" meeting via Webex.  In that meeting discussed our branching strategy, and possible tools that we would use in order to complete the App. 
* We decided on to have a branching strategy that would include a Master Branch, Production Branch, and Individual Branches. 
* As a group we decided that each time a Developer pushed to their branch, perform a pull request to merge from their branch to Production. We setup rules in Github to require two reviews before the branch could be merged.  Once two Developers reviewed the code and merged, each of us would pull the latest version to our local repo. After successful acceptance of that feature, we would merge from Production Branch to Master Branch. 
* Next, using Dependency Inversion, we decided to start with the UI.  
* In order to get acquainted with each other's work, we took the time to review previous Capstone Projects done by the team members.  This step was critical, because it would determine how much time needed to be focused on the Front End. 
*
*
*
*
*
<h2>
    3. Executing the Plan
</h2>
*
*
*
*
*
*
*
*
<h2>
    4. Reflection / Refactor
</h2>
*
*
*
*
*
*
*
*